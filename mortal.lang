//O comentário indica que ~deveria~ dar ruim

byte 1: byte = 3.3; 	//é real
byte 2: byte = 2;
byte 3: byte = 3;
float 1: float = 2.0;
float 2: float = 2; 	//é byte
float 3: float[5] 0.0 1.1 2.2 3.3; //falta um arg
float 1: float = 2.0;	//redeclaração
float 1: byte = 3.2; 	//redeclaração + float

(byte) funcao byte (a: byte, b: float)
{
	return (a+b);	//erro no return (float)
}

(long) funcao long ()
{
	//Chamada de funcao cagada
	funcao byte = byte 1;	// funcao na attr
	//funcao byte (byte 1, float 1) = byte 2; //funcao na attr
	byte 3 = funcao byte (float 1, byte 1); //args trocados
	byte 3 = funcao byte (float 1); //arg trocado e menos args
	byte 3 = funcao byte (byte 1); //menos args
	byte 3 = funcao byte (byte 1, float 1);

	//Byte to float e outras putarias
	byte 1 = byte 2;
	byte 2 = float 1;	// float to byte
	float 1 = byte 2;	// byte to float
	float 1 = float 3 [3];
	float 3 [float 1] = float 2;	//float no index
	float 3 [1 - 0.5] = float 2;	//float no index
	float 3 [1 < 0] = float 2;	//bool no index
	float 3 [byte 1 + 19999999] = byte 1; // byte to float
	float 1 = funcao byte (byte 1, float 1); //byte to float
	
	//Lógico-aritméticas -> essa vai ser louca
	
	
	return (1);
}
